
core/freepbx.py:

import time
import re
import logging
from typing import Dict, List, Tuple, Optional

import requests

log = logging.getLogger(__name__)


class AlreadyExists(Exception):
    """Raised when an entity already exists on FreePBX side."""
    pass


class FreePBX:
    def __init__(self, base_url: str, client_id: str, client_secret: str, verify: bool = True):
        self.base_url = base_url.rstrip("/")
        self.client_id = client_id
        self.client_secret = client_secret
        self.verify = verify
        self.token: Optional[str] = None
        self.token_exp: float = 0.0

    # ----- URLs -----
    @property
    def token_url(self) -> str:
        return f"{self.base_url}/admin/api/api/token"

    @property
    def gql_url(self) -> str:
        return f"{self.base_url}/admin/api/api/gql"

    # ----- Auth / GQL -----
    def ensure_token(self) -> None:
        now = time.time()
        if self.token and now < self.token_exp - 30:
            return
        data = {
            "grant_type": "client_credentials",
            "client_id": self.client_id,
            "client_secret": self.client_secret,
            "scope": "gql gql:core",
        }
        r = requests.post(self.token_url, data=data, timeout=25, verify=self.verify)
        r.raise_for_status()
        j = r.json()
        self.token = j["access_token"]
        self.token_exp = now + int(j.get("expires_in", 3600))

    def gql(self, query: str, variables: Optional[dict] = None) -> dict:
        self.ensure_token()
        h = {"Authorization": f"Bearer {self.token}"}
        r = requests.post(
            self.gql_url,
            json={"query": query, "variables": variables or {}},
            timeout=35,
            verify=self.verify,
            headers=h,
        )
        r.raise_for_status()
        js = r.json()
        if "errors" in js:
            raise RuntimeError(js["errors"])
        return js["data"]

    # ----- Extensions: read -----
    def fetch_all_extensions(self) -> List[Tuple[str, str]]:
        q_full = """
        query {
          fetchAllExtensions {
            extension {
              extensionId
              tech
              pjsip { secret }
              user { password extPassword }
            }
          }
        }
        """
        q_fallback = """
        query {
          fetchAllExtensions {
            extension {
              extensionId
              user { password extPassword }
            }
          }
        }
        """
        try:
            data = self.gql(q_full)
            exts = data["fetchAllExtensions"]["extension"]
        except Exception:
            data = self.gql(q_fallback)
            exts = data["fetchAllExtensions"]["extension"]

        out: List[Tuple[str, str]] = []
        for e in exts:
            ext = str(e["extensionId"])
            u = e.get("user") or {}
            pw = u.get("extPassword") or (e.get("pjsip", {}) or {}).get("secret") or u.get("password") or ""
            out.append((ext, pw))
        out.sort(key=lambda x: int(re.sub(r"\D", "", x[0]) or 0))
        return out

    def fetch_ext_index(self):
        queries = [
            """
            query {
              fetchAllExtensions {
                extension {
                  extensionId
                  user { extPassword name displayname }
                }
              }
            }
            """,
            """
            query {
              fetchAllExtensions {
                extension {
                  extensionId
                  user { password }
                }
              }
            }
            """,
            """
            query {
              fetchAllExtensions {
                extension { extensionId }
              }
            }
            """,
        ]

        def pick_name(e: dict) -> str:
            u = e.get("user") or {}
            for k in ("name", "displayname", "username"):
                v = u.get(k)
                if isinstance(v, str) and v.strip():
                    return v.strip()
            return ""

        for q in queries:
            try:
                data = self.gql(q)
                exts = data["fetchAllExtensions"]["extension"]
                by_ext: Dict[str, Dict[str, str]] = {}
                name_set = set()
                for e in exts:
                    ext = str(e["extensionId"])
                    name = pick_name(e)
                    by_ext[ext] = {"name": name, "pw": ""}  # pw не трогаем здесь
                    if name:
                        name_set.add(name.lower())
                return by_ext, name_set, bool(name_set)
            except Exception:
                continue

        return {}, set(), False

    # ----- Extensions: write -----
    def delete_extension(self, extension: str) -> None:
        ext_str = str(extension)
        variants = [
            ("ID",     "id",           "input"),
            ("String", "id",           "input"),
            ("ID",     "extensionId",  "input"),
            ("String", "extensionId",  "input"),
            ("ID",     "extension",    "input"),
            ("String", "extension",    "input"),
            ("ID",     "extId",        "input"),
            ("String", "extId",        "input"),
            ("ID",     "id",           "direct"),
            ("String", "id",           "direct"),
            ("ID",     "extensionId",  "direct"),
            ("String", "extensionId",  "direct"),
            ("ID",     "extension",    "direct"),
            ("String", "extension",    "direct"),
            ("ID",     "extId",        "direct"),
            ("String", "extId",        "direct"),
        ]
        last_err = None
        for typ, field, mode in variants:
            if mode == "input":
                m = f"""
                mutation($ext: {typ}!) {{
                  deleteExtension(input: {{ {field}: $ext }}) {{ status message }}
                }}
                """
            else:
                m = f"""
                mutation($ext: {typ}!) {{
                  deleteExtension({field}: $ext) {{ status message }}
                }}
                """
            try:
                self.gql(m, {"ext": ext_str})
                return
            except Exception as e:
                last_err = e
                continue
        raise RuntimeError(f"deleteExtension failed (all variants): {last_err}")

    def create_one(self, ext: int, name: Optional[str] = None) -> None:
        m = """
        mutation($start: ID!, $name: String!, $email: String!) {
          createRangeofExtension(input:{
            startExtension: $start,
            numberOfExtensions: 1,
            tech: "pjsip",
            name: $name,
            email: $email,
            vmEnable: true,
            umEnable: true
          }) {
            status
            message
          }
        }
        """
        nm = str(name).strip() if (name and str(name).strip()) else str(ext)
        vars = {
            "start": str(ext),
            "name": nm,
            "email": f"{ext}@local",
        }
        self.gql(m, vars)

    def set_ext_password(self, extension: str, secret: str) -> None:
        m_id = """
        mutation($extId: ID!, $name: String!, $pwd: String!) {
          updateExtension(input: {
            extensionId: $extId,
            name: $name,
            extPassword: $pwd
          }) { status message }
        }
        """
        m_str = """
        mutation($extId: String!, $name: String!, $pwd: String!) {
          updateExtension(input: {
            extensionId: $extId,
            name: $name,
            extPassword: $pwd
          }) { status message }
        }
        """
        vars_id = {"extId": str(extension), "name": str(extension), "pwd": secret}
        try:
            self.gql(m_id, vars_id)
        except Exception as e1:
            vars_str = {"extId": str(extension), "name": str(extension), "pwd": secret}
            try:
                self.gql(m_str, vars_str)
            except Exception as e2:
                raise RuntimeError(f"updateExtension failed: ID! -> {e1}; String! -> {e2}")

    # ----- Apply Config -----
    def apply_config(self) -> dict:
        gql_mutation = """
        mutation {
            doreload(input: {}) {
              status
              message
              transaction_id
            }
        }
        """
        try:
            data = self.gql(gql_mutation)
            return data.get("doreload") or {"status": True, "message": "doreload ok"}
        except Exception as e1:
            url = f"{self.base_url}/admin/ajax.php"
            try:
                r = requests.get(url, params={"command": "reload"}, timeout=25, verify=self.verify)
                r.raise_for_status()
                try:
                    return {"status": True, "message": str(r.json())[:400]}
                except ValueError:
                    return {"status": True, "message": r.text[:400]}
            except Exception as e2:
                raise RuntimeError(f"Apply Config failed: GraphQL doreload -> {e1}; ajax reload -> {e2}")

    # ----- Inbound Routes -----
    def create_inbound_route(self, did: str, description: str, ext: str) -> None:
        did = str(did).strip()
        description = str(description).strip()
        ext = str(ext).strip()

        candidates = [
            f"from-did-direct,{ext},1",
            f"ext-local,{ext},1",
        ]

        def _post_gql(mutation: str, variables: dict):
            self.ensure_token()
            h = {"Authorization": f"Bearer {self.token}"}
            resp = requests.post(
                self.gql_url,
                json={"query": mutation, "variables": variables},
                timeout=35,
                verify=self.verify,
                headers=h,
            )
            text = resp.text
            try:
                data = resp.json()
            except Exception:
                data = None

            if not resp.ok:
                lower = (text or "").lower()
                if any(k in lower for k in ("already", "exist", "duplicate", "unique")):
                    raise AlreadyExists(text[:300])
                resp.raise_for_status()

            if isinstance(data, dict) and "errors" in data:
                joined = " | ".join(str(e.get("message", "")) for e in data["errors"])
                lower = joined.lower()
                if any(k in lower for k in ("already", "exist", "duplicate", "unique")):
                    raise AlreadyExists(joined[:300])
                raise RuntimeError(joined or "GraphQL error")

            return data

        mutation = """
        mutation($did:String!, $desc:String!, $dest:String!) {
            addInboundRoute(input:{
                extension: $did,
                description: $desc,
                destination: $dest
            }) {
                status
                message
                inboundRoute { id }
            }
        }"""

        last_err: Optional[Exception] = None
        for dest in candidates:
            try:
                _post_gql(mutation, {"did": did, "desc": description, "dest": dest})
                return
            except AlreadyExists:
                raise
            except Exception as e:
                last_err = e
                continue

        msg = str(last_err) if last_err else ""
        if "Cannot query field" in msg and "addInboundRoute" in msg:
            raise RuntimeError(
                "На этой версии FreePBX отсутствует мутация addInboundRoute. "
                "Обнови модули framework/core/api до последних версий."
            )
        raise RuntimeError(f"create_inbound_route failed: {last_err}")
    
    # ===== Inbound Routes: find =====
    def _try_fetch_inbound_routes(self) -> list:
        queries = [
            """
            query {
              fetchAllInboundRoutes {
                inboundRoute { id extension description destination }
              }
            }
            """,
            """
            query {
              inboundRoutes {
                inboundRoute { id extension description destination }
              }
            }
            """,
            """
            query {
              fetchInboundRoutes {
                inboundRoute { id extension description destination }
              }
            }
            """,
        ]
        last_err = None
        for q in queries:
            try:
                data = self.gql(q)
                # пытаемся вытащить первый встретившийся контейнер
                for key in ("fetchAllInboundRoutes", "inboundRoutes", "fetchInboundRoutes"):
                    if key in data and data[key] and "inboundRoute" in data[key]:
                        arr = data[key]["inboundRoute"] or []
                        # normalize
                        out = []
                        for r in arr:
                            out.append({
                                "id": str(r.get("id")) if r.get("id") is not None else None,
                                "extension": str(r.get("extension") or "").strip(),
                                "description": str(r.get("description") or "").strip(),
                                "destination": str(r.get("destination") or "").strip(),
                            })
                        return out
            except Exception as e:
                last_err = e
                continue
        raise RuntimeError(f"Не удалось получить список inbound routes: {last_err}")

    def find_inbound_route(self, did: str) -> Optional[dict]:
        """
        Возвращает словарь маршрута по DID (extension) или None.
        """
        did = str(did).strip()
        routes = self._try_fetch_inbound_routes()
        for r in routes:
            if r.get("extension") == did:
                return r
        return None

    def delete_inbound_route(self, route_id: str):
        q = """
        mutation ($input: removeInboundRouteInput!) {
        removeInboundRoute(input: $input) {
            status
            message
        }
        }
        """
        variables = {"input": {"id": route_id}}
        data = self.gql(q, variables)
        return data.get("removeInboundRoute") or {}
    
    def list_inbound_routes(self):
        """
        Возвращает список inbound routes: id, extension, description
        """
        q = """
        query {
        allInboundRoutes {
            inboundRoutes {
            id
            extension
            description
            }
        }
        }
        """
        data = self.gql(q)
        conns = data.get("allInboundRoutes") or {}
        routes = conns.get("inboundRoutes") or []
        out = []
        for r in routes:
            out.append({
                "id": str(r.get("id") or ""),
                "extension": str(r.get("extension") or ""),
                "description": str(r.get("description") or ""),
            })
        return out
    
    def list_query_fields(self):
        q = """
        query {
        __schema {
            queryType {
            fields { name }
            }
        }
        }
        """
        data = self.gql(q)
        return [f["name"] for f in data["__schema"]["queryType"]["fields"]]
    
    def list_mutations(self):
        q = """
        query {
        __schema {
            mutationType {
            fields { name }
            }
        }
        }
        """
        data = self.gql(q)
        return [f["name"] for f in data["__schema"]["mutationType"]["fields"]]









handlers/callbacks.py:

from html import escape
from typing import List, Tuple

from telegram import Update
from telegram.ext import ContextTypes
from telegram.constants import ChatAction

from .commands import (
    _ensure_connected,
    fb_from_session,
    _slice_pairs,
)
from ui.texts import _list_nav_kb, _list_page_text
from utils.common import clean_url


async def list_nav_cb(u: Update, c: ContextTypes.DEFAULT_TYPE):
    """
    Обработчик пагинации списка EXT.
    callback_data: "list:page:<N>"
    """
    q = u.callback_query
    data = q.data
    if not data.startswith("list:page:"):
        await q.answer()
        return

    try:
        page = int(data.split(":")[-1])

        # Берём кешированный список, если есть
        pairs: List[Tuple[str, str]] = c.user_data.get("__last_pairs")
        fb = fb_from_session(u.effective_chat.id)
        if pairs is None:
            pairs = fb.fetch_all_extensions()
            c.user_data["__last_pairs"] = pairs

        pairs_page, page, pages = _slice_pairs(pairs, page=page)
        await q.message.edit_text(
            _list_page_text(clean_url(fb.base_url), pairs_page),
            reply_markup=_list_nav_kb(page, pages)
        )
        await q.answer()
    except Exception:
        await q.answer("Ошибка")


async def del_all_cb(u: Update, c: ContextTypes.DEFAULT_TYPE):
    """
    Подтверждение полного удаления всех линий.
    callback_data: "delall:yes" | "delall:no"
    """
    if not await _ensure_connected(u):
        return

    q = u.callback_query
    if not q.data.startswith("delall:"):
        await q.answer()
        return

    answer = q.data.split(":")[1]
    if answer == "no":
        await q.edit_message_text("Отменено.")
        await q.answer("Отмена")
        return

    try:
        fb = fb_from_session(u.effective_chat.id)
        await q.edit_message_text("⏳ Удаляю все линии… (подготовка)")
        pairs = fb.fetch_all_extensions()
        total = len(pairs)
        done = 0

        await q.message.chat.send_action(ChatAction.TYPING)
        for ext, _ in pairs:
            try:
                fb.delete_extension(ext)
            except Exception:
                pass
            done += 1
            if done % 25 == 0 or done == total:
                try:
                    await q.edit_message_text(f"⏳ Удаляю все линии… ({done}/{total})")
                except Exception:
                    pass

        # Apply Config при наличии удалений
        if total:
            try:
                try:
                    await q.edit_message_text("🔄 Применяю конфиг (Apply Config)…")
                except Exception:
                    pass
                fb.apply_config()
            except Exception as e:
                try:
                    await q.edit_message_text(
                        f"Удаление выполнено, но Apply Config не удалось: <code>{escape(str(e))}</code>"
                    )
                except Exception:
                    pass
                await q.answer("Ошибка Apply Config")
                return

        await q.edit_message_text(f"{fb.base_url}\n\n(всё удалено)")
        await q.answer("Готово")
    except Exception as e:
        await q.edit_message_text(f"Ошибка удаления: <code>{escape(str(e))}</code>")
        await q.answer("Ошибка")


async def noop_cb(u: Update, c: ContextTypes.DEFAULT_TYPE):
    """Пустой обработчик для 'noop'."""
    await u.callback_query.answer()
    


handlers/commands.py:

# src/handlers/commands.py
import os
import re
import time
import asyncio
import secrets
import logging
from html import escape
from typing import Dict, List, Tuple, Optional
from urllib.parse import urlparse
from telegram import BotCommand

from telegram import (
    Update, ReplyKeyboardMarkup, InlineKeyboardMarkup, InlineKeyboardButton,     
    BotCommand,
    BotCommandScopeAllPrivateChats,
    BotCommandScopeAllGroupChats,
    BotCommandScopeAllChatAdministrators,
    ReplyKeyboardRemove
    )
from telegram.ext import ContextTypes
from telegram.constants import ParseMode, ChatAction

from core.freepbx import FreePBX, AlreadyExists
from ui.texts import HELP_TEXT, _list_nav_kb, _list_page_text
from utils.common import clean_url, equip_start, parse_targets, next_free

from ui.keyboards import main_menu_kb

log = logging.getLogger(__name__)

# ----- Session / settings -----
SESS: Dict[int, dict] = {}
PAGE_SIZE = 50
ADMIN_CHAT_ID = os.getenv("ADMIN_CHAT_ID")


# ===== Internal helpers =====
def fb_from_session(chat_id: int) -> FreePBX:
    s = SESS.get(chat_id)
    if not s:
        raise RuntimeError("Сначала /connect <ip> <login> <password>")
    fb = FreePBX(s["base_url"], s["client_id"], s["client_secret"], verify=s["verify"])
    fb.token = s.get("token")
    fb.token_exp = s.get("token_exp", 0)
    return fb

def _need_connect_text() -> str:
    return "Сначала подключитесь:\n<code>/connect &lt;ip&gt; &lt;login&gt; &lt;password&gt;</code>"

async def _ensure_connected(u: Update) -> bool:
    chat = u.effective_chat
    if chat and chat.id in SESS:
        return True
    if getattr(u, "message", None):
        await u.message.reply_text(_need_connect_text())
    elif getattr(u, "callback_query", None):
        await u.callback_query.answer("Сначала подключитесь: /connect <ip> <login> <password>", show_alert=True)
    return False

def _slice_pairs(pairs, page: int, page_size: int = PAGE_SIZE):
    total = len(pairs)
    pages = max(1, (total + page_size - 1) // page_size)
    page = max(0, min(page, pages - 1))
    start = page * page_size
    end = start + page_size
    return pairs[start:end], page, pages


# ===== Commands =====
async def start_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    # Сначала уберём старую reply-клавиатуру, если была
    await u.message.reply_text(
        "👋 Привет! Я помогу управлять FreePBX: подключение, список SIP, создание и удаление.\n"
        "Набери /help для инструкции.",
        reply_markup=ReplyKeyboardRemove()
    )
    # И сразу покажем inline-главное меню
    await u.message.reply_text(
        "🏠 <b>Главное меню</b>",
        parse_mode=ParseMode.HTML,
        reply_markup=main_menu_kb(),
    )

async def help_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    await u.message.reply_text(HELP_TEXT)


async def connect_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    if len(c.args) < 3:
        await u.message.reply_text(
            "Формат:\n"
            "<code>/connect &lt;ip&gt; &lt;login&gt; &lt;password&gt;</code>\n"
            "Пример: <code>/connect http://77.105.146.189 CID SECRET</code>"
        )
        return

    raw_ip, login, password = c.args[0], c.args[1], c.args[2]
    parsed = urlparse(raw_ip)
    if not parsed.scheme:
        base_url = f"http://{raw_ip}"
        verify = False
    else:
        base_url = raw_ip
        verify = not base_url.startswith("http://")

    await u.message.chat.send_action(ChatAction.TYPING)
    fb = FreePBX(base_url, login, password, verify=verify)

    try:
        fb.ensure_token()
        SESS[u.effective_chat.id] = {
            "base_url": fb.base_url,
            "client_id": login,
            "client_secret": password,
            "verify": verify,
            "token": fb.token,
            "token_exp": fb.token_exp,
        }

        # ставим флаг для меню
        c.user_data["__connected"] = True

        pairs = fb.fetch_all_extensions()
        c.user_data["__last_pairs"] = pairs
        pairs_page, page, pages = _slice_pairs(pairs, page=0)
        text = _list_page_text(clean_url(fb.base_url), pairs_page)
        kb = _list_nav_kb(page, pages)

        await u.message.reply_text(f"✅ Подключено к <code>{escape(fb.base_url)}</code>")

        # Показать главное меню
        await u.message.reply_text(
            "🏠 <b>Главное меню</b>",
            parse_mode=ParseMode.HTML,
            reply_markup=main_menu_kb(),
        )

        # (как и раньше) список экстеншенов
        await u.message.reply_text(text, reply_markup=kb)

    except Exception as e:
        await u.message.reply_text(f"Ошибка подключения: <code>{escape(str(e))}</code>")


async def list_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    if not await _ensure_connected(u):
        return
    try:
        fb = fb_from_session(u.effective_chat.id)
        pairs = fb.fetch_all_extensions()
        c.user_data["__last_pairs"] = pairs
        pairs_page, page, pages = _slice_pairs(pairs, page=0)

        target = u.effective_message  # универсальная цель ответа
        await target.reply_text(
            _list_page_text(clean_url(fb.base_url), pairs_page),
            reply_markup=_list_nav_kb(page, pages)
        )
    except Exception as e:
        target = u.effective_message
        await target.reply_text(f"Ошибка: <code>{escape(str(e))}</code>")


async def create_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    target = u.effective_message  # универсальная "точка ответа" (и для message, и для callback)

    if len(c.args) < 2:
        await target.reply_text(
            "❗ Формат команды:\n"
            "<code>/create &lt;оборудование&gt; &lt;кол-во&gt;</code>\n\n"
            "Где <b>оборудование</b> — номер базы (старт EXT):\n"
            "• 1 → 101…\n• 2 → 201…\n• 3 → 301…\n• 4 → 401…\n• 10 → 1001…\n\n"
            "Пример:\n<code>/create 4 10</code> — создаст 10 линий, начиная с 401.\n",
        )
        return

    if not await _ensure_connected(u):
        return

    try:
        eq = int(c.args[0])
        cnt = int(c.args[1])
        if cnt <= 0:
            raise ValueError
    except Exception:
        await target.reply_text(
            "❗ Некорректные аргументы.\n"
            "Используй: <code>/create &lt;оборудование&gt; &lt;кол-во&gt;</code>\n"
            "Например: <code>/create 4 10</code>"
        )
        return

    fb = fb_from_session(u.effective_chat.id)
    try:
        notice = await target.reply_text(f"⏳ Создаю {cnt} линий… (0/{cnt})")
        await target.chat.send_action(ChatAction.TYPING)

        all_pairs = fb.fetch_all_extensions()
        existing = [ext for ext, _ in all_pairs]
        start = equip_start(eq)
        targets = next_free(existing, start, cnt)

        created = 0
        for i, ext in enumerate(targets, 1):
            fb.create_one(int(ext))
            secret = secrets.token_hex(16)
            fb.set_ext_password(ext, secret)

            created += 1
            if created % 5 == 0 or created == cnt:
                try:
                    await notice.edit_text(f"⏳ Создаю {cnt} линий… ({created}/{cnt})")
                except Exception:
                    pass
            await asyncio.sleep(0)

        if targets:
            try:
                try:
                    await notice.edit_text("🔄 Применяю конфиг (Apply Config)…")
                except Exception:
                    pass
                fb.apply_config()
                try:
                    await notice.edit_text("✅ Конфиг применён. Обновляю список…")
                except Exception:
                    pass
            except Exception as e:
                await target.reply_text(f"⚠️ Apply Config не удалось: <code>{escape(str(e))}</code>")

        pairs = fb.fetch_all_extensions()
        c.user_data["__last_pairs"] = pairs
        pairs_page, page, pages = _slice_pairs(pairs, page=0)

        await target.reply_text(
            _list_page_text(clean_url(fb.base_url), pairs_page),
            reply_markup=_list_nav_kb(page, pages)
        )
    except Exception as e:
        await target.reply_text(f"Ошибка создания: <code>{escape(str(e))}</code>")


async def del_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    target = u.effective_message
    if not c.args:
        await target.reply_text("Формат: /del 401 402 410-418")
        return
    if not await _ensure_connected(u):
        return

    fb = fb_from_session(u.effective_chat.id)
    requested = parse_targets(" ".join(c.args))
    try:
        await target.chat.send_action(ChatAction.TYPING)
        by_ext, _, _ = fb.fetch_ext_index()
        existing = set(by_ext.keys())

        targets = [x for x in requested if x in existing]
        missing = [x for x in requested if x not in existing]

        total = len(targets)
        notice = await target.reply_text(f"⏳ Удаляю линии… (0/{total})") if total else None

        ok, failed = [], []
        for i, ext in enumerate(targets, 1):
            try:
                fb.delete_extension(ext)
                ok.append(ext)
            except Exception:
                failed.append(ext)
            if notice and (i % 10 == 0 or i == total):
                try:
                    await notice.edit_text(f"⏳ Удаляю линии… ({i}/{total})")
                except Exception:
                    pass
            await asyncio.sleep(0)

        parts = []
        if ok:      parts.append("🗑️ Удалено: " + ", ".join(ok))
        if missing: parts.append("↩️ Пропущено (нет такой линии): " + ", ".join(missing))
        if failed:  parts.append("❌ Ошибка удаления: " + ", ".join(failed))
        if not parts: parts.append("Нечего удалять.")
        await target.reply_text("\n".join(parts))

        if ok:
            try:
                if notice:
                    try: await notice.edit_text("🔄 Применяю конфиг (Apply Config)…")
                    except Exception: pass
                fb.apply_config()
                if notice:
                    try: await notice.edit_text("✅ Конфиг применён. Обновляю список…")
                    except Exception: pass
            except Exception as e:
                await target.reply_text(f"⚠️ Apply Config не удалось: <code>{escape(str(e))}</code>")

        pairs = fb.fetch_all_extensions()
        c.user_data["__last_pairs"] = pairs
        page_items, page, pages = _slice_pairs(pairs, page=0)
        await target.reply_text(
            _list_page_text(clean_url(fb.base_url), page_items),
            reply_markup=_list_nav_kb(page, pages)
        )
    except Exception as e:
        await target.reply_text(f"Ошибка удаления: <code>{escape(str(e))}</code>")

async def del_eq_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    target = u.effective_message
    if not c.args:
        await target.reply_text("Формат: /del_eq <оборудование>")
        return
    if not await _ensure_connected(u):
        return
    eq = int(c.args[0])
    start = equip_start(eq)
    end = start + 99
    c.args = [f"{start}-{end}"]
    await del_cmd(u, c)

async def del_all_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    if not await _ensure_connected(u):
        return
    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton("Да, удалить всё", callback_data="delall:yes"),
         InlineKeyboardButton("Отмена", callback_data="delall:no")]
    ])
    await u.message.reply_text("⚠️ Точно удалить все линии?", reply_markup=kb)

async def add_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    if not c.args:
        await u.message.reply_text(
            "Форматы:\n"
            "<code>/add &lt;ext&gt; [имя]</code>\n"
            "<code>/add &lt;start-end&gt; [префикс_имени]</code>\n"
            "Примеры:\n"
            "<code>/add 101</code>\n"
            "<code>/add 101 Офис Киев</code>\n"
            "<code>/add 101-105 Продажи</code>"
        )
        return
    if not await _ensure_connected(u):
        return

    fb = fb_from_session(u.effective_chat.id)
    arg0 = c.args[0]
    name_tail = " ".join(c.args[1:]).strip()
    try:
        await u.message.chat.send_action(ChatAction.TYPING)

        targets = parse_targets(arg0) if "-" in arg0 else [arg0]
        total = len(targets)
        notice = await u.message.reply_text(f"⏳ Добавляю линии… (0/{total})")

        by_ext, name_set, name_ok = fb.fetch_ext_index()
        existing_exts = set(by_ext.keys())

        created, skipped_ext, skipped_name = [], [], []
        name_check_warn = False

        processed = 0
        for raw in targets:
            ext = str(int(raw))
            cand_name = (f"{name_tail} {ext}" if "-" in arg0 else name_tail) if name_tail else ext

            if ext in existing_exts:
                skipped_ext.append(ext)
            elif name_ok and cand_name.strip().lower() in name_set:
                skipped_name.append(f"{ext} ({cand_name})")
            else:
                if not name_ok:
                    name_check_warn = True
                fb.create_one(int(ext), cand_name)
                secret = secrets.token_hex(16)
                fb.set_ext_password(ext, secret)
                created.append(ext)
                existing_exts.add(ext)
                if name_ok and cand_name.strip():
                    name_set.add(cand_name.strip().lower())

            processed += 1
            if processed % 5 == 0 or processed == total:
                try:
                    await notice.edit_text(f"⏳ Добавляю линии… ({processed}/{total})")
                except Exception:
                    pass
            await asyncio.sleep(0)

        parts = []
        if created:
            parts.append("✅ Создано: " + ", ".join(created))
        if skipped_ext:
            parts.append("↩️ Уже существуют EXT: " + ", ".join(skipped_ext))
        if skipped_name:
            parts.append("🔁 Дубли имён: " + ", ".join(skipped_name))
        if name_check_warn:
            parts.append("ℹ️ Имя проверить не удалось (сервер не отдаёт имена).")
        if not parts:
            parts.append("Нечего делать.")
        await u.message.reply_text("\n".join(parts))

        if created:
            try:
                try:
                    await notice.edit_text("🔄 Применяю конфиг (Apply Config)…")
                except Exception:
                    pass
                fb.apply_config()
                try:
                    await notice.edit_text("✅ Конфиг применён. Обновляю список…")
                except Exception:
                    pass
            except Exception as e:
                await u.message.reply_text(f"⚠️ Apply Config не удалось: <code>{escape(str(e))}</code>")

        pairs = fb.fetch_all_extensions()
        c.user_data["__last_pairs"] = pairs
        page_items, page, pages = _slice_pairs(pairs, page=0)
        await u.message.reply_text(
            _list_page_text(clean_url(fb.base_url), page_items),
            reply_markup=_list_nav_kb(page, pages)
        )
    except Exception as e:
        await u.message.reply_text(f"Ошибка /add: <code>{escape(str(e))}</code>")

async def reconnect_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    if not await _ensure_connected(u):
        return
    try:
        target = u.effective_message
        s = SESS.get(u.effective_chat.id)
        fb = FreePBX(s["base_url"], s["client_id"], s["client_secret"], verify=s["verify"])
        fb.ensure_token()
        s["token"] = fb.token
        s["token_exp"] = fb.token_exp
        await target.reply_text("🔁 Переподключение выполнено.")
    except Exception as e:
        await target.reply_text(f"Ошибка reconnect: <code>{escape(str(e))}</code>")

async def ping_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    if not await _ensure_connected(u):
        return
    try:
        target = u.effective_message
        fb = fb_from_session(u.effective_chat.id)
        fb.ensure_token()
        _ = fb.gql("query { fetchAllExtensions { extension { extensionId } } }")
        await target.reply_text("✅ OK")
    except Exception as e:
        await target.reply_text(f"❌ Unauthorized / ошибка: <code>{escape(str(e))}</code>")

async def whoami_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    if not await _ensure_connected(u):
        return
    target = u.effective_message
    s = SESS.get(u.effective_chat.id)
    ttl = max(0, int(s.get("token_exp", 0) - time.time()))
    await target.reply_text(
        "👤 Текущая сессия\n"
        f"URL: <code>{s['base_url']}</code>\n"
        f"Client ID: <code>{s['client_id']}</code>\n"
        f"TLS verify: <code>{s['verify']}</code>\n"
        f"Токен жив ещё: <code>{ttl} сек</code>"
    )

async def logout_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    target = u.effective_message
    SESS.pop(u.effective_chat.id, None)
    c.user_data.clear()
    await target.reply_text("🚪 Сессия сброшена. Используйте /connect.")

async def list_routes_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    if not await _ensure_connected(u):
        return
    fb = fb_from_session(u.effective_chat.id)
    target = u.effective_message
    try:
        routes = fb.list_inbound_routes()
        if not routes:
            await target.reply_text("Маршрутов не найдено.")
            return
        lines = ["DID | Description | ID"]
        for r in routes:
            did = r.get("extension")
            desc = r.get("description")
            rid = r.get("id")
            lines.append(f"{did} | {desc} | {rid}")
        await target.reply_text("\n".join(lines))
    except Exception as e:
        await target.reply_text(f"Ошибка /list_routes: <code>{escape(str(e))}</code>")



async def add_inbound_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    """
    /add_inbound 414
    /add_inbound 414-420
    Для каждого существующего EXT создаём inbound route:
    DID=_sim{ext}, Description=sim{ext}, Destination -> Extension {ext}
    """
    target = u.effective_message

    if not c.args:
        await target.reply_text(
            "Форматы:\n"
            "<code>/add_inbound &lt;ext&gt;</code>\n"
            "<code>/add_inbound &lt;start-end&gt;</code>\n"
            "Примеры:\n"
            "<code>/add_inbound 414</code>\n"
            "<code>/add_inbound 401-418</code>\n"
            "Маршрут создаётся только если EXT существует. DID будет в формате <code>_simEXT</code>."
        )
        return
    if not await _ensure_connected(u):
        return

    fb = fb_from_session(u.effective_chat.id)
    arg0 = " ".join(c.args)
    targets = parse_targets(arg0)

    try:
        await target.chat.send_action(ChatAction.TYPING)

        # Индекс существующих EXT
        by_ext, _, _ = fb.fetch_ext_index()
        existing_exts = set(by_ext.keys())

        # Уже существующие DID у маршрутов (для защиты от дублей, учитываем оба формата)
        routes_now = fb.list_inbound_routes()
        existing_dids = {r.get("extension") for r in routes_now if r.get("extension")}

        todo = [x for x in targets if x in existing_exts]
        missing = [x for x in targets if x not in existing_exts]

        total = len(todo)
        if total == 0:
            msg = ["Нечего создавать."]
            if missing:
                msg.append("↩️ Пропущено (нет таких EXT): " + ", ".join(missing))
            await target.reply_text("\n".join(msg))
            return

        notice = await target.reply_text(f"⏳ Добавляю Inbound Routes… (0/{total})")

        ok, skipped_exists, failed = [], [], []
        for i, ext in enumerate(todo, 1):
            did_plain = ext
            did_prefx = f"_sim{ext}"
            # если уже есть старый маршрут (DID=ext) или новый (DID=_simext) — пропустим
            if did_plain in existing_dids or did_prefx in existing_dids:
                skipped_exists.append(ext)
            else:
                try:
                    fb.create_inbound_route(did=did_prefx, description=f"sim{ext}", ext=ext)
                    ok.append(ext)
                    existing_dids.add(did_prefx)
                except AlreadyExists:
                    skipped_exists.append(ext)
                except Exception as e:
                    failed.append(f"{ext} ({str(e)[:80]})")

            if i % 5 == 0 or i == total:
                try:
                    await notice.edit_text(f"⏳ Добавляю Inbound Routes… ({i}/{total})")
                except Exception:
                    pass
            await asyncio.sleep(0)

        parts = []
        if ok:
            parts.append("✅ Создано маршрутов: " + ", ".join(ok))
        if skipped_exists:
            parts.append("↩️ Пропущено (уже есть DID ext или _simext): " + ", ".join(skipped_exists))
        if missing:
            parts.append("↩️ Нет таких EXT: " + ", ".join(missing))
        if failed:
            parts.append("❌ Ошибки: " + ", ".join(failed))
        await target.reply_text("\n".join(parts) if parts else "Нечего делать.")

        if ok:
            try:
                try:
                    await notice.edit_text("🔄 Применяю конфиг (Apply Config)…")
                except Exception:
                    pass
                fb.apply_config()
                try:
                    await notice.edit_text("✅ Конфиг применён.")
                except Exception:
                    pass
            except Exception as e:
                await target.reply_text(f"⚠️ Apply Config не удалось: <code>{escape(str(e))}</code>")

    except Exception as e:
        await target.reply_text(f"Ошибка /add_inbound: <code>{escape(str(e))}</code>")


async def del_inbound_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    """
    /del_inbound <ext>
    Удаляет inbound route по extension (DID).
    Принимаем EXT без префикса, а ищем DID и как _simEXT, и как старый EXT.
    """
    target = u.effective_message

    if not c.args:
        await target.reply_text("Использование: <code>/del_inbound &lt;ext&gt;</code>")
        return
    if not await _ensure_connected(u):
        return

    fb = fb_from_session(u.effective_chat.id)
    number = c.args[0]

    try:
        await target.chat.send_action(ChatAction.TYPING)

        routes = fb.list_inbound_routes()
        did_new = f"_sim{number}"
        # Сначала ищем новый формат
        route = next((r for r in routes if r.get("extension") == did_new), None)
        # Затем — старый формат (на всякий случай)
        if not route:
            route = next((r for r in routes if r.get("extension") == number), None)

        if not route:
            await target.reply_text(f"❌ Маршрут для EXT {number} не найден (ни DID={did_new}, ни DID={number})")
            return

        shown = route.get("extension") or number
        notice = await target.reply_text(f"⏳ Удаляю Inbound Route {shown}…")

        res = fb.delete_inbound_route(route["id"])
        status = (res.get("status") if isinstance(res, dict) else None)
        msg = (res.get("message") if isinstance(res, dict) else "") or ""

        status_str = str(status).lower() if status is not None else ""
        okish = status_str in ("ok", "true") or "success" in msg.lower()

        if okish:
            await notice.edit_text(f"✅ Маршрут {shown} удалён. 🔄 Применяю конфиг…")
            try:
                fb.apply_config()
                await notice.edit_text(f"✅ Маршрут {shown} удалён.\n✅ Конфиг применён.")
            except Exception as e:
                await notice.edit_text(
                    f"✅ Маршрут {shown} удалён.\n⚠️ Apply Config не удалось: {escape(str(e))}"
                )
        else:
            await notice.edit_text(f"❌ Ошибка удаления {shown}: {msg or res}")

    except Exception as e:
        await target.reply_text(f"Ошибка /del_inbound: <code>{escape(str(e))}</code>")



async def gql_fields_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    if not await _ensure_connected(u):
        return
    fb = fb_from_session(u.effective_chat.id)
    target = u.effective_message
    try:
        fields = fb.list_query_fields()
        if not fields:
            await target.reply_text("Query-поля не найдены.")
            return
        chunk = []
        total = 0
        for f in fields:
            line = f"- {f}"
            if sum(len(x) for x in chunk) + len(line) + 1 > 3500:
                await target.reply_text("Доступные Query:\n" + "\n".join(chunk))
                chunk = []
            chunk.append(line)
            total += 1
        if chunk:
            await target.reply_text("Доступные Query:\n" + "\n".join(chunk))
    except Exception as e:
        await target.reply_text(f"Ошибка introspect: {escape(str(e))}")
        

async def gql_mutations_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    if not await _ensure_connected(u):
        return
    fb = fb_from_session(u.effective_chat.id)
    target = u.effective_message
    try:
        muts = fb.list_mutations()
        if not muts:
            await target.reply_text("Mutation-поля не найдены.")
            return
        chunk = []
        total = 0
        for m in muts:
            line = f"- {m}"
            if sum(len(x) for x in chunk) + len(line) + 1 > 3500:
                await target.reply_text("Доступные Mutation:\n" + "\n".join(chunk))
                chunk = []
            chunk.append(line)
            total += 1
        if chunk:
            await target.reply_text("Доступные Mutation:\n" + "\n".join(chunk))
    except Exception as e:
        await target.reply_text(f"Ошибка introspect: {escape(str(e))}")
        
async def menu_cmd(u: Update, c: ContextTypes.DEFAULT_TYPE):
    if not await _ensure_connected(u):
        return
    target = u.effective_message
    await target.reply_text(
        "🏠 <b>Главное меню</b>",
        parse_mode=ParseMode.HTML,
        reply_markup=main_menu_kb(),
    )

# ===== Lifecycle hook (used in main.py via .post_init(on_startup)) =====
async def on_startup(app):
    print("✅ Бот запущен и слушает обновления. Набери /help в Telegram для инструкции.")
    log.info("✅ Бот запущен и слушает обновления. Команда помощи: /help")

    if ADMIN_CHAT_ID:
        try:
            await app.bot.send_message(int(ADMIN_CHAT_ID), "✅ Бот запущен и готов к работе. Напишите /help.")
        except Exception as e:
            log.warning(f"Не удалось отправить сообщение админу: {e}")

    try:
        await app.bot.delete_my_commands()  # default
        await app.bot.delete_my_commands(scope=BotCommandScopeAllPrivateChats())
        await app.bot.delete_my_commands(scope=BotCommandScopeAllGroupChats())
        await app.bot.delete_my_commands(scope=BotCommandScopeAllChatAdministrators())

        commands = [
            BotCommand("start", "Запуск"),
            BotCommand("help", "Помощь"),
            BotCommand("connect", "Подключиться к FreePBX"),
            BotCommand("menu", "Главное меню"),
            BotCommand("list", "Список EXT"),
            BotCommand("create", "Создать по базе"),
            BotCommand("add", "Добавить EXT/диапазон"),
            BotCommand("del", "Удалить EXT/диапазон"),
            BotCommand("del_eq", "Удалить по базе (100 номеров)"),
            BotCommand("del_all", "Удалить все EXT"),
            BotCommand("add_inbound", "Создать inbound (EXT/диапазон)"),
            BotCommand("del_inbound", "Удалить inbound по DID"),
            BotCommand("list_routes", "Список inbound маршрутов"),
            BotCommand("reconnect", "Переподключиться"),
            BotCommand("ping", "Проверка GraphQL"),
            BotCommand("whoami", "Текущая сессия"),
            BotCommand("logout", "Сброс сессии"),
        ]

        await app.bot.set_my_commands(commands)  # default
        await app.bot.set_my_commands(commands, scope=BotCommandScopeAllPrivateChats())
        await app.bot.set_my_commands(commands, scope=BotCommandScopeAllGroupChats())
        await app.bot.set_my_commands(commands, scope=BotCommandScopeAllChatAdministrators())

        try:
            await app.bot.set_chat_menu_button()  # вернёт стандартную «голубую» кнопку
        except Exception:
            pass
    except Exception as e:
        print(f"set_my_commands failed: {e}")

handlers/menu.py:

from telegram import Update
from telegram.constants import ParseMode
from telegram.ext import ContextTypes
from telegram.error import BadRequest

from ui.keyboards import (
    MENU_PREFIX, main_menu_kb, back_home_kb,
    ext_menu_kb, in_menu_kb, sys_menu_kb, gql_menu_kb
)
from ui.texts import NOT_CONNECTED

from handlers.commands import (
    list_cmd, create_cmd, add_cmd, del_cmd, 
    reconnect_cmd, ping_cmd, whoami_cmd, logout_cmd, 
    gql_fields_cmd, gql_mutations_cmd,
    list_routes_cmd, add_inbound_cmd, del_inbound_cmd
)

from utils.common import equip_start
# ===== helpers =====

def _is_connected(context: ContextTypes.DEFAULT_TYPE) -> bool:
    return bool(context.user_data.get("__connected"))

async def _safe_edit(q, text, **kwargs):
    try:
        return await q.edit_message_text(text, **kwargs)
    except BadRequest as e:
        if "message is not modified" in str(e).lower():
            return None
        raise

def _mk_inline(spec_rows):
    from telegram import InlineKeyboardMarkup, InlineKeyboardButton
    rows = []
    for row in spec_rows:
        rows.append([InlineKeyboardButton(b["text"], callback_data=b["data"]) for b in row])
    return InlineKeyboardMarkup(rows)

async def send_main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    target = update.effective_message
    await target.reply_text(
        "🏠 <b>Главное меню</b>",
        parse_mode=ParseMode.HTML,
        reply_markup=main_menu_kb(),
    )


# ===== ЭКРАНЫ: Создание =====

async def _ext_create_root(q, *, text_suffix: str = ""):
    txt = (
        "➕ <b>Создание линий</b>\n"
        "Выберите способ:\n\n"
        "• По оборудованию (например, 4 → 401…)\n"
        "• Один номер (EXT)\n"
        "• Диапазон (start-end)\n"
    )
    if text_suffix:
        txt += f"\n<code>{text_suffix}</code>"
    kb = [
        [dict(text="🏭 По оборудованию", data=f"{MENU_PREFIX}ext.create.eq")],
        [
            dict(text="1️⃣ Один номер", data=f"{MENU_PREFIX}ext.create.single"),
            dict(text="↔️ Диапазон",    data=f"{MENU_PREFIX}ext.create.range"),
        ],
        [dict(text="🔙 Назад", data=f"{MENU_PREFIX}ext")],
    ]
    await _safe_edit(q, txt, parse_mode=ParseMode.HTML, reply_markup=_mk_inline(kb))

async def _ext_create_pick_eq(q):
    txt = "🏭 Выберите <b>оборудование</b> (стартовая база EXT):"
    kb = [
        [
            dict(text="1 → 101…", data=f"{MENU_PREFIX}ext.create.eq.1"),
            dict(text="2 → 201…", data=f"{MENU_PREFIX}ext.create.eq.2"),
        ],
        [
            dict(text="3 → 301…", data=f"{MENU_PREFIX}ext.create.eq.3"),
            dict(text="4 → 401…", data=f"{MENU_PREFIX}ext.create.eq.4"),
        ],
        [dict(text="10 → 1001…", data=f"{MENU_PREFIX}ext.create.eq.10")],
        [dict(text="✍️ Ввести номер базы", data=f"{MENU_PREFIX}ext.create.eq.custom")],  # ← НОВОЕ
        [dict(text="🔙 Назад",   data=f"{MENU_PREFIX}ext.create")],
    ]
    await _safe_edit(q, txt, parse_mode=ParseMode.HTML,
                     reply_markup=_mk_inline(kb))


async def _ext_create_pick_qty(q, eq: int):
    txt = f"📦 База <b>{eq}</b>. Выберите <b>количество</b> линий:"
    kb = [
        [
            dict(text="1",  data=f"{MENU_PREFIX}ext.create.eqqty.{eq}.1"),
            dict(text="5",  data=f"{MENU_PREFIX}ext.create.eqqty.{eq}.5"),
            dict(text="10", data=f"{MENU_PREFIX}ext.create.eqqty.{eq}.10"),
        ],
        [
            dict(text="20",            data=f"{MENU_PREFIX}ext.create.eqqty.{eq}.20"),
            dict(text="50",            data=f"{MENU_PREFIX}ext.create.eqqty.{eq}.50"),
            dict(text="✍️ Ввести число", data=f"{MENU_PREFIX}ext.create.eqqty.custom.{eq}"),
        ],
        [dict(text="🔙 Назад", data=f"{MENU_PREFIX}ext.create.eq")],
    ]
    await _safe_edit(q, txt, parse_mode=ParseMode.HTML, reply_markup=_mk_inline(kb))
    
async def _ext_create_pick_qty_send(target_message, eq: int):
    txt = f"📦 База <b>{eq}</b>. Выберите <b>количество</b> линий:"
    kb = [
        [
            dict(text="1",  data=f"{MENU_PREFIX}ext.create.eqqty.{eq}.1"),
            dict(text="5",  data=f"{MENU_PREFIX}ext.create.eqqty.{eq}.5"),
            dict(text="10", data=f"{MENU_PREFIX}ext.create.eqqty.{eq}.10"),
        ],
        [
            dict(text="20",            data=f"{MENU_PREFIX}ext.create.eqqty.{eq}.20"),
            dict(text="50",            data=f"{MENU_PREFIX}ext.create.eqqty.{eq}.50"),
            dict(text="✍️ Ввести число", data=f"{MENU_PREFIX}ext.create.eqqty.custom.{eq}"),
        ],
        [dict(text="🔙 Назад", data=f"{MENU_PREFIX}ext.create.eq")],
    ]
    await target_message.reply_text(
        txt, parse_mode=ParseMode.HTML, reply_markup=_mk_inline(kb)
    )


async def _in_add_pick_eq(q):
    txt = "🏭 Выберите <b>базу</b>, для которой создать inbound-маршруты для ВСЕХ существующих EXT (диапазон 100 номеров):"
    kb = [
        [
            dict(text="1 → 101-199",  data=f"{MENU_PREFIX}in.add.eq.1"),
            dict(text="2 → 201-299",  data=f"{MENU_PREFIX}in.add.eq.2"),
        ],
        [
            dict(text="3 → 301-399",  data=f"{MENU_PREFIX}in.add.eq.3"),
            dict(text="4 → 401-499",  data=f"{MENU_PREFIX}in.add.eq.4"),
        ],
        [dict(text="10 → 1001-1099", data=f"{MENU_PREFIX}in.add.eq.10")],
        [dict(text="✍️ Ввести номер базы", data=f"{MENU_PREFIX}in.add.eq.custom")],  # ← НОВОЕ
        [dict(text="🔙 Назад",        data=f"{MENU_PREFIX}in")],
    ]
    await _safe_edit(q, txt, parse_mode=ParseMode.HTML, reply_markup=_mk_inline(kb))



# ===== ЭКРАНЫ: Удаление =====

async def _ext_delete_root(q):
    txt = (
        "🗑️ <b>Удаление линий</b>\n"
        "Выберите способ:\n"
        "• Удалить по номерам/диапазону (например, 401 402 410-418)\n"
        "• Удалить все 100 номеров конкретной базы (1→101…, 4→401… и т.д.)\n"
        "• Удалить ВСЁ (все EXT)\n"
    )
    kb = [
        [dict(text="🔢 Удалить номера/диапазон", data=f"{MENU_PREFIX}ext.del.numbers")],
        [dict(text="🏭 Удалить по базе",         data=f"{MENU_PREFIX}ext.del.eq")],
        [dict(text="🧨 Удалить ВСЁ",             data=f"{MENU_PREFIX}ext.del_all")],
        [dict(text="🔙 Назад",                   data=f"{MENU_PREFIX}ext")],
    ]
    await _safe_edit(q, txt, parse_mode=ParseMode.HTML, reply_markup=_mk_inline(kb))

async def _ext_delete_pick_eq(q):
    txt = "🏭 Выберите <b>базу</b> для удаления её диапазона (100 номеров):"
    kb = [
        [
            dict(text="1 → 101-199",  data=f"{MENU_PREFIX}ext.del.eq.1"),
            dict(text="2 → 201-299",  data=f"{MENU_PREFIX}ext.del.eq.2"),
        ],
        [
            dict(text="3 → 301-399",  data=f"{MENU_PREFIX}ext.del.eq.3"),
            dict(text="4 → 401-499",  data=f"{MENU_PREFIX}ext.del.eq.4"),
        ],
        [dict(text="10 → 1001-1099", data=f"{MENU_PREFIX}ext.del.eq.10")],
        [dict(text="✍️ Ввести номер базы", data=f"{MENU_PREFIX}ext.del.eq.custom")],  # ← НОВОЕ
        [dict(text="🔙 Назад",        data=f"{MENU_PREFIX}ext")],
    ]
    await _safe_edit(q, txt, parse_mode=ParseMode.HTML, reply_markup=_mk_inline(kb))



# ===== ТЕКСТОВЫЙ РОУТЕР (ввод пользователя) =====

async def menu_text_router(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Регистрируется в main.py как MessageHandler(filters.TEXT & ~filters.COMMAND)."""
    if not _is_connected(context):
        return

    st = context.user_data.get("__await")
    if not st:
        return

    kind = st.get("kind")
    text = (update.message.text or "").strip()

    # создать по базе — ввод количества
    if kind == "create_eq_qty":
        eq = int(st["eq"])
        try:
            qty = int(text)
            if qty <= 0:
                raise ValueError
        except Exception:
            await update.message.reply_text("❗ Введите целое положительное число. Например: 10")
            return
        context.args = [str(eq), str(qty)]
        await create_cmd(update, context)
        context.user_data.pop("__await", None)
        return

    # один номер
    if kind == "add_single":
        parts = text.split(maxsplit=1)
        try:
            ext = str(int(parts[0]))
        except Exception:
            await update.message.reply_text("❗ Введите EXT, например: 101 или '101 Офис Киев'")
            return
        name = parts[1] if len(parts) > 1 else ""
        context.args = [ext] + ([name] if name else [])
        await add_cmd(update, context)
        context.user_data.pop("__await", None)
        return

    # диапазон
    if kind == "add_range":
        parts = text.split(maxsplit=1)
        rng = parts[0]
        name_prefix = parts[1] if len(parts) > 1 else ""
        if "-" not in rng:
            await update.message.reply_text("❗ Введите диапазон в формате 101-105 (и опц. префикс)")
            return
        a, b = rng.split("-", 1)
        try:
            _ = int(a); _ = int(b)
        except Exception:
            await update.message.reply_text("❗ Диапазон должен быть числами, например 401-418")
            return
        context.args = [rng] + ([name_prefix] if name_prefix else [])
        await add_cmd(update, context)
        context.user_data.pop("__await", None)
        return

    # удаление — ввод произвольных номеров/диапазонов
    if kind == "del_numbers":
        context.args = [text]  # весь ввод пойдёт в del_cmd
        await del_cmd(update, context)
        context.user_data.pop("__await", None)
        return
    
    # Inbound: добавление (EXT или диапазон)
    if kind == "in_add":
        # принимаем "414" или "401-418"
        text = (update.message.text or "").strip()
        if not text:
            await update.message.reply_text("❗ Введите EXT или диапазон, например: 414 или 401-418")
            return
        # просто прокидываем как аргументы в add_inbound_cmd
        context.args = [text]
        await add_inbound_cmd(update, context)
        context.user_data.pop("__await", None)
        return

    # Inbound: удаление по DID (EXT)
    if kind == "in_del":
        did = (update.message.text or "").strip()
        try:
            _ = int(did)
        except Exception:
            await update.message.reply_text("❗ DID должен быть числом, например: 414")
            return
        context.args = [did]
        await del_inbound_cmd(update, context)
        context.user_data.pop("__await", None)
        return
    
    # Создание EXT: пользователь вручную вводит номер базы
    if kind == "create_eq_pick":
        txt = (update.message.text or "").strip()
        try:
            eq = int(txt)
            _ = equip_start(eq)
        except Exception:
            await update.message.reply_text(
                "❗ Некорректный номер базы. Введите одно из: 1, 2, 3, 4, 10."
            )
            return
        await _ext_create_pick_qty_send(update.effective_message, eq)
        context.user_data.pop("__await", None)
        return

    if kind == "in_add_eq_pick":
        txt = (update.message.text or "").strip()
        try:
            eq = int(txt)
            start = equip_start(eq)
            end = start + 99
        except Exception:
            await update.message.reply_text(
                "❗ Некорректный номер базы. Введите одно из: 1, 2, 3, 4, 10."
            )
            return
        context.args = [f"{start}-{end}"]
        await add_inbound_cmd(update, context)
        context.user_data.pop("__await", None)
        return
    
    if kind == "del_eq_pick":
        txt = (update.message.text or "").strip()
        try:
            eq = int(txt)
            # валидируем, что такая база поддерживается (equip_start бросит, если нет)
            from utils.common import equip_start
            _ = equip_start(eq)
        except Exception:
            await update.message.reply_text(
                "❗ Некорректный номер базы. Введите одно из: 1, 2, 3, 4, 10."
            )
            return

        from handlers.commands import del_eq_cmd  
        context.args = [str(eq)]
        await del_eq_cmd(update, context)

        context.user_data.pop("__await", None)
        return


    context.user_data.pop("__await", None)


# ===== ГЛАВНЫЙ РОУТЕР КНОПОК =====

async def menu_router(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()

    if not _is_connected(context):
        await _safe_edit(q, NOT_CONNECTED, parse_mode=ParseMode.HTML, reply_markup=back_home_kb())
        return

    data = q.data  # например: "menu:ext.create.eqqty.4.10"
    route = data[len(MENU_PREFIX):]

    # разделы
    if route == "home":
        await _safe_edit(q, "🏠 <b>Главное меню</b>", parse_mode=ParseMode.HTML, reply_markup=main_menu_kb()); return
    if route == "ext":
        await _safe_edit(q, "🧩 <b>Extensions</b> — выберите действие:", parse_mode=ParseMode.HTML, reply_markup=ext_menu_kb()); return
    if route == "ext.create.eq.custom":
        context.user_data["__await"] = {"kind": "create_eq_pick"}
        await _safe_edit(
            q,
            "✍️ Введите номер <b>базы</b> (например: 1, 2, 3, 4, 10).",
            parse_mode=ParseMode.HTML,
            reply_markup=back_home_kb()
        )
        return
    if route == "ext.del.eq.custom":
        context.user_data["__await"] = {"kind": "del_eq_pick"}
        await _safe_edit(
            q,
            "✍️ Введите номер <b>базы</b> (например: 1, 2, 3, 4, 10).",
            parse_mode=ParseMode.HTML,
            reply_markup=back_home_kb()
        )
        return
    if route == "in":
        await _safe_edit(q, "⬅️ <b>Inbound</b> — выберите действие:", parse_mode=ParseMode.HTML, reply_markup=in_menu_kb()); return
    if route == "in.list":
        await list_routes_cmd(update, context)
        return
    if route == "in.add":
        context.user_data["__await"] = {"kind": "in_add"}
        await _safe_edit(
            q,
            "✍️ Введите EXT или диапазон для создания inbound route(ов).\n"
            "Примеры:\n"
            "<code>414</code>\n"
            "<code>401-418</code>\n"
            "Описание будет вида <code>sim{ext}</code>, назначение — на Extension {ext}.",
            parse_mode=ParseMode.HTML,
            reply_markup=back_home_kb()
        )
        return
    if route == "in.add.eq":
        await _in_add_pick_eq(q)
        return
    if route == "in.add.eq.custom":
        context.user_data["__await"] = {"kind": "in_add_eq_pick"}
        await _safe_edit(
            q,
            "✍️ Введите номер <b>базы</b> (например: 1, 2, 3, 4, 10).",
            parse_mode=ParseMode.HTML,
            reply_markup=back_home_kb()
        )
        return
    if route.startswith("in.add.eq."):
        eq = int(route.split(".")[-1])
        start = equip_start(eq)           
        end = start + 99                  
        context.args = [f"{start}-{end}"] 
        await add_inbound_cmd(update, context)
        return
    if route == "in.del":
        context.user_data["__await"] = {"kind": "in_del"}
        await _safe_edit(
            q,
            "✍️ Введите DID (EXT) маршрута, который нужно удалить.\n"
            "Например: <code>414</code>",
            parse_mode=ParseMode.HTML,
            reply_markup=back_home_kb()
        )
        return

    if route == "sys":
        await _safe_edit(q, "🛠 <b>System</b> — выберите действие:", parse_mode=ParseMode.HTML, reply_markup=sys_menu_kb()); return
    
    if route == "sys.reconnect":
        await reconnect_cmd(update, context)
        return

    if route == "sys.ping":
        await ping_cmd(update, context)
        return

    if route == "sys.whoami":
        await whoami_cmd(update, context)
        return

    if route == "sys.logout":
        await logout_cmd(update, context)
        await _safe_edit(q, "🏠 <b>Главное меню</b>", parse_mode=ParseMode.HTML, reply_markup=main_menu_kb())
        return

    if route == "gql":
        await _safe_edit(q, "🧬 <b>GraphQL</b> — выберите действие:", parse_mode=ParseMode.HTML, reply_markup=gql_menu_kb()); return
    if route == "gql.fields":
        await gql_fields_cmd(update, context)
        return
    if route == "gql.mutations":
        await gql_mutations_cmd(update, context)
        return

    if route == "help":
        await _safe_edit(q, "ℹ️ <b>Help</b>. Команды доступны через меню.", parse_mode=ParseMode.HTML, reply_markup=back_home_kb()); return

    # список
    if route == "ext.list":
        await list_cmd(update, context); return

    # создание
    if route == "ext.create":
        await _ext_create_root(q); return
    if route == "ext.create.eq":
        await _ext_create_pick_eq(q); return
    if route.startswith("ext.create.eq."):
        eq = int(route.split(".")[-1])
        await _ext_create_pick_qty(q, eq); return
    if route.startswith("ext.create.eqqty."):
        parts = route.split(".")
        if len(parts) >= 4 and parts[3] == "custom":
            eq = int(parts[4])
            context.user_data["__await"] = {"kind": "create_eq_qty", "eq": eq}
            await _safe_edit(q,
                f"✍️ Введите <b>количество</b> для базы <b>{eq}</b> (целое число):",
                parse_mode=ParseMode.HTML,
                reply_markup=back_home_kb()
            )
            return
        eq = int(parts[3]); qty = int(parts[4])
        context.args = [str(eq), str(qty)]
        await create_cmd(update, context); return
    if route == "ext.create.single":
        context.user_data["__await"] = {"kind": "add_single"}
        await _safe_edit(q,
            "✍️ Введите EXT и (опционально) имя. Примеры:\n"
            "<code>101</code>\n"
            "<code>101 Офис Киев</code>",
            parse_mode=ParseMode.HTML, reply_markup=back_home_kb()
        ); return
    if route == "ext.create.range":
        context.user_data["__await"] = {"kind": "add_range"}
        await _safe_edit(q,
            "✍️ Введите диапазон и (опционально) префикс имени. Примеры:\n"
            "<code>101-105</code>\n"
            "<code>401-418 Продажи</code>",
            parse_mode=ParseMode.HTML, reply_markup=back_home_kb()
        ); return

    # удаление
    if route == "ext.del":
        await _ext_delete_root(q); return
    if route == "ext.del.numbers":
        context.user_data["__await"] = {"kind": "del_numbers"}
        await _safe_edit(q,
            "✍️ Введите номера/диапазоны для удаления.\n"
            "Примеры:\n"
            "<code>401</code>\n"
            "<code>401 402 410-418</code>",
            parse_mode=ParseMode.HTML, reply_markup=back_home_kb()
        ); return
    if route in ("ext.del.eq", "ext.del_root"):
        await _ext_delete_pick_eq(q); return
    if route.startswith("ext.del.eq."):
        eq = int(route.split(".")[-1])
        context.args = [f"{eq}"]
        from handlers.commands import del_eq_cmd  # локальный импорт
        await del_eq_cmd(update, context); return
    if route == "ext.del_all":
        from telegram import InlineKeyboardMarkup, InlineKeyboardButton
        kb = InlineKeyboardMarkup([
            [InlineKeyboardButton("Да, удалить всё", callback_data="delall:yes"),
             InlineKeyboardButton("Отмена",          callback_data="delall:no")]
        ])
        await _safe_edit(q, "⚠️ Точно удалить все линии?", parse_mode=ParseMode.HTML, reply_markup=kb); return

    # фоллбек
    await _safe_edit(q,
        f"⏳ Нажато: <code>{route}</code>. Раздел в разработке.",
        parse_mode=ParseMode.HTML, reply_markup=back_home_kb()
    )

ui/keyboards.py:

from telegram import InlineKeyboardButton, InlineKeyboardMarkup

MENU_PREFIX = "menu:"  # общий префикс для навигации

def main_menu_kb() -> InlineKeyboardMarkup:
    rows = [
        [
            InlineKeyboardButton("🧩 Extensions", callback_data=f"{MENU_PREFIX}ext"),
            InlineKeyboardButton("⬅️ Inbound",    callback_data=f"{MENU_PREFIX}in"),
        ],
        [
            InlineKeyboardButton("🛠 System",     callback_data=f"{MENU_PREFIX}sys"),
            InlineKeyboardButton("🧬 GraphQL",    callback_data=f"{MENU_PREFIX}gql"),
        ],
        [InlineKeyboardButton("ℹ️ Help",         callback_data=f"{MENU_PREFIX}help")],
    ]
    return InlineKeyboardMarkup(rows)

def back_home_kb() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        [[InlineKeyboardButton("🔙 Назад", callback_data=f"{MENU_PREFIX}home")]]
    )

def ext_menu_kb() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("📋 Список",            callback_data=f"{MENU_PREFIX}ext.list"),
            InlineKeyboardButton("✨ Создать",            callback_data=f"{MENU_PREFIX}ext.create"),
        ],
        [
            InlineKeyboardButton("🗑️ Удалить номера",    callback_data=f"{MENU_PREFIX}ext.del"),
        ],
        [
            InlineKeyboardButton("🧨 Удалить ВСЁ",       callback_data=f"{MENU_PREFIX}ext.del_all"),
        ],
        [InlineKeyboardButton("⬅️ Назад",               callback_data=f"{MENU_PREFIX}home")],
    ])

def in_menu_kb() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("📋 Список",         callback_data=f"{MENU_PREFIX}in.list"),
            InlineKeyboardButton("➕ Добавить",       callback_data=f"{MENU_PREFIX}in.add"),
        ],
        [
            InlineKeyboardButton("🏭➕ Для всей базы", callback_data=f"{MENU_PREFIX}in.add.eq"),
            InlineKeyboardButton("🗑️ Удалить",        callback_data=f"{MENU_PREFIX}in.del"),
        ],
        [InlineKeyboardButton("⬅️ Назад",            callback_data=f"{MENU_PREFIX}home")],
    ])
    
def sys_menu_kb() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("🔄 Reconnect", callback_data=f"{MENU_PREFIX}sys.reconnect"),
            InlineKeyboardButton("🏓 Ping",       callback_data=f"{MENU_PREFIX}sys.ping"),
        ],
        [
            InlineKeyboardButton("👤 WhoAmI",     callback_data=f"{MENU_PREFIX}sys.whoami"),
            InlineKeyboardButton("🚪 Logout",     callback_data=f"{MENU_PREFIX}sys.logout"),
        ],
        [InlineKeyboardButton("🔙 Назад",         callback_data=f"{MENU_PREFIX}home")],
    ])

def gql_menu_kb() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("📑 Fields",     callback_data=f"{MENU_PREFIX}gql.fields"),
            InlineKeyboardButton("⚒ Mutations",   callback_data=f"{MENU_PREFIX}gql.mutations"),
        ],
        [InlineKeyboardButton("🔙 Назад",         callback_data=f"{MENU_PREFIX}home")],
    ])

ui/texts.py:

# src/ui/texts.py
from telegram import InlineKeyboardMarkup, InlineKeyboardButton

HELP_TEXT = (
    "📘 <b>Помощь</b>\n\n"
    "🔌 <b>Подключение к FreePBX</b>\n"
    "  <code>/connect &lt;ip&gt; &lt;login&gt; &lt;password&gt;</code>\n"
    "  • <i>ip</i> — базовый URL FreePBX (например: http://77.105.146.189)\n"
    "  • <i>login</i> — Client ID из FreePBX API\n"
    "  • <i>password</i> — Client Secret из FreePBX API\n\n"

    "📄 <b>Список линий</b>\n"
    "  <code>/list</code> — список EXT и паролей (с навигацией)\n\n"

    "🆕 <b>Создание линий</b>\n"
    "  <code>/create &lt;оборудование&gt; &lt;кол-во&gt;</code>\n"
    "  • старт номеров: 1→101, 2→201, 3→301, 4→401, 10→1001\n"
    "  • пример: <code>/create 4 10</code> (создаст 401… по порядку)\n\n"

    "🗑️ <b>Удаление линий</b>\n"
    "  • Точечно/диапазон: <code>/del 401 402 410-418</code>\n"
    "  • По оборудованию:  <code>/del_eq 4</code> (все 401–499)\n"
    "  • Все сразу:        <code>/del_all</code>\n\n"

    "♻️ <b>Сессия</b>\n"
    "  <code>/reconnect</code> — переподключение с последними данными\n"
    "  <code>/ping</code> — проверка токена и GraphQL (OK/ошибка)\n"
    "  <code>/whoami</code> — показать текущий URL и Client ID\n"
    "  <code>/logout</code> — сброс сессии\n\n"
    
    "🧩 <b>Добавление линий</b>\n"
    "  <code>/add &lt;ext&gt; [имя]</code>\n"
    "  <code>/add &lt;start-end&gt; [префикс_имени]</code>\n"
    "  • Проверка дублей по номеру и имени\n\n"
    
    "📥 <b>Inbound Routes</b>\n"
    "  <code>/list_routes</code> — список всех маршрутов\n"
    "  <code>/add_inbound &lt;ext&gt;</code> или <code>/add_inbound &lt;start-end&gt;</code>\n"
    "    • Создаёт маршрут DID→EXT, Description=simEXT\n"
    "  <code>/del_inbound &lt;ext&gt;</code>\n"
    "    • Удаляет маршрут по DID\n\n"
)



def _list_page_text(ip: str, pairs_page):
    """Собрать текст для страницы списка EXT/паролей."""
    if not pairs_page:
        return f"{ip}\n\n(пусто)"
    lines = [ip, ""]
    lines += [f"{ext} {pw}" for ext, pw in pairs_page]
    return "\n".join(lines)


def _list_nav_kb(page: int, pages: int):
    """Построить клавиатуру навигации по страницам."""
    prev_btn = InlineKeyboardButton("⬅️", callback_data=f"list:page:{page-1}")
    next_btn = InlineKeyboardButton("➡️", callback_data=f"list:page:{page+1}")
    nums = InlineKeyboardButton(f"{page+1}/{pages}", callback_data="noop")
    row = []
    if page > 0:
        row.append(prev_btn)
    row.append(nums)
    if page < pages - 1:
        row.append(next_btn)
    return InlineKeyboardMarkup([row]) if pages > 1 else None

MENU_WELCOME = (
    "✅ Подключение успешно.\n"
    "Выбирайте раздел ниже — больше не нужно писать команды вручную."
)

NOT_CONNECTED = (
    "❗️Сначала подключитесь: "
    "<code>/connect &lt;ip&gt; &lt;login&gt; &lt;password&gt;</code>"
)

utils/common.py:

import re
from typing import List, Tuple


def clean_url(url: str) -> str:
    """
    Убирает протокол и слэши в конце для красивого отображения.
    http://1.2.3.4/  ->  1.2.3.4
    """
    return re.sub(r"^https?://", "", url).rstrip("/")


def equip_start(eq: int) -> int:
    """
    Расчёт стартового EXT для базы оборудования:
      1 -> 101, 2 -> 201, 3 -> 301, 4 -> 401, 10 -> 1001
    """
    return eq * 100 + 1


def parse_targets(s: str) -> List[str]:
    """
    Разбирает строку с номерами/диапазонами в список EXT.
    Пример: "401 402 410-418" -> ["401","402","410","411",...,"418"]
    """
    out: List[str] = []
    for tok in s.strip().split():
        if "-" in tok:
            a, b = tok.split("-", 1)
            for n in range(int(a), int(b) + 1):
                out.append(str(n))
        else:
            out.append(tok)
    return sorted(set(out), key=lambda x: int(x))


def next_free(existing: List[str], start: int, count: int) -> List[str]:
    """
    Находит первые count свободных EXT, начиная со start,
    исключая те, что уже есть в existing.
    """
    taken = set(map(int, existing))
    res, cur = [], start
    while len(res) < count:
        if cur not in taken:
            res.append(str(cur))
        cur += 1
    return res


def format_list(ip: str, pairs: List[Tuple[str, str]]) -> str:
    """
    Формирует список EXT/паролей в текстовом виде.
    """
    if not pairs:
        return f"{ip}\n\n(пусто)"
    lines = [ip, ""]
    lines += [f"{ext} {pw}" for ext, pw in pairs]
    return "\n".join(lines)

main.py:

import os
from telegram.ext import Application, Defaults, CommandHandler, CallbackQueryHandler, MessageHandler, filters
from telegram.constants import ParseMode
from dotenv import load_dotenv
from handlers.commands import list_routes_cmd
from handlers.menu import menu_router, menu_text_router  

from handlers.commands import (
    start_cmd, help_cmd, connect_cmd, list_cmd, create_cmd, del_cmd,
    del_eq_cmd, del_all_cmd, add_cmd, reconnect_cmd,
    ping_cmd, whoami_cmd, logout_cmd, on_startup, gql_fields_cmd, gql_mutations_cmd,
    menu_cmd, add_inbound_cmd, del_inbound_cmd

)
from handlers.callbacks import list_nav_cb, del_all_cb, noop_cb


def _get_token() -> str:
    load_dotenv()
    token = os.getenv("TELEGRAM_TOKEN", "").strip()
    if not token or token == "PUT_YOUR_TELEGRAM_BOT_TOKEN":
        raise RuntimeError(
            "TELEGRAM_TOKEN не задан. Укажи переменную окружения TELEGRAM_TOKEN "
            "или заполни её в .env"
        )
    return token

def build_app():
    token = _get_token()
    defaults = Defaults(parse_mode=ParseMode.HTML)
    app = Application.builder().token(token).defaults(defaults).post_init(on_startup).build()

    app.add_handler(CommandHandler("start", start_cmd))
    app.add_handler(CommandHandler("help", help_cmd))
    app.add_handler(CommandHandler("connect", connect_cmd))
    app.add_handler(CommandHandler("list", list_cmd))
    app.add_handler(CommandHandler("create", create_cmd))
    app.add_handler(CommandHandler("del", del_cmd))
    app.add_handler(CommandHandler("del_eq", del_eq_cmd))
    app.add_handler(CommandHandler("del_all", del_all_cmd))
    app.add_handler(CommandHandler("add", add_cmd))
    app.add_handler(CommandHandler("add_inbound", add_inbound_cmd))
    app.add_handler(CommandHandler("reconnect", reconnect_cmd))
    app.add_handler(CommandHandler("ping", ping_cmd))
    app.add_handler(CommandHandler("whoami", whoami_cmd))
    app.add_handler(CommandHandler("logout", logout_cmd))
    app.add_handler(CommandHandler("del_inbound", del_inbound_cmd))
    app.add_handler(CommandHandler("list_routes", list_routes_cmd))
    app.add_handler(CommandHandler("gql_fields", gql_fields_cmd))
    app.add_handler(CommandHandler("gql_mutations", gql_mutations_cmd))
    app.add_handler(CommandHandler("menu", menu_cmd))

    app.add_handler(CallbackQueryHandler(menu_router, pattern=r"^menu:"))
    app.add_handler(CallbackQueryHandler(list_nav_cb, pattern=r"^list:page:"))
    app.add_handler(CallbackQueryHandler(del_all_cb, pattern=r"^delall:"))
    app.add_handler(CallbackQueryHandler(noop_cb, pattern=r"^noop$"))
    app.add_handler(MessageHandler(filters.TEXT & (~filters.COMMAND), menu_text_router))

    return app

if __name__ == "__main__":
    build_app().run_polling()
